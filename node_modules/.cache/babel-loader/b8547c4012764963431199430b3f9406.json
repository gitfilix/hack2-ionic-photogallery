{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/rubendiaz/projects/hackaton/hack2-ionic-photogallery/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _toConsumableArray from \"/Users/rubendiaz/projects/hackaton/hack2-ionic-photogallery/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _regeneratorRuntime from \"/Users/rubendiaz/projects/hackaton/hack2-ionic-photogallery/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/rubendiaz/projects/hackaton/hack2-ionic-photogallery/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/rubendiaz/projects/hackaton/hack2-ionic-photogallery/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/rubendiaz/projects/hackaton/hack2-ionic-photogallery/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/rubendiaz/projects/hackaton/hack2-ionic-photogallery/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/rubendiaz/projects/hackaton/hack2-ionic-photogallery/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { WebPlugin } from '@capacitor/core';\nexport var FilesystemWeb = /*#__PURE__*/function (_WebPlugin) {\n  _inherits(FilesystemWeb, _WebPlugin);\n\n  var _super = _createSuper(FilesystemWeb);\n\n  function FilesystemWeb() {\n    var _this;\n\n    _classCallCheck(this, FilesystemWeb);\n\n    _this = _super.apply(this, arguments);\n    _this.DB_VERSION = 1;\n    _this.DB_NAME = 'Disc';\n    _this._writeCmds = ['add', 'put', 'delete'];\n    return _this;\n  }\n\n  _createClass(FilesystemWeb, [{\n    key: \"initDb\",\n    value: function () {\n      var _initDb = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this2 = this;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(this._db !== undefined)) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", this._db);\n\n              case 2:\n                if ('indexedDB' in window) {\n                  _context.next = 4;\n                  break;\n                }\n\n                throw this.unavailable(\"This browser doesn't support IndexedDB\");\n\n              case 4:\n                return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  var request = indexedDB.open(_this2.DB_NAME, _this2.DB_VERSION);\n                  request.onupgradeneeded = FilesystemWeb.doUpgrade;\n\n                  request.onsuccess = function () {\n                    _this2._db = request.result;\n                    resolve(request.result);\n                  };\n\n                  request.onerror = function () {\n                    return reject(request.error);\n                  };\n\n                  request.onblocked = function () {\n                    console.warn('db blocked');\n                  };\n                }));\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function initDb() {\n        return _initDb.apply(this, arguments);\n      }\n\n      return initDb;\n    }()\n  }, {\n    key: \"dbRequest\",\n    value: function () {\n      var _dbRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(cmd, args) {\n        var readFlag;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                readFlag = this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';\n                return _context2.abrupt(\"return\", this.initDb().then(function (conn) {\n                  return new Promise(function (resolve, reject) {\n                    var tx = conn.transaction(['FileStorage'], readFlag);\n                    var store = tx.objectStore('FileStorage');\n                    var req = store[cmd].apply(store, _toConsumableArray(args));\n\n                    req.onsuccess = function () {\n                      return resolve(req.result);\n                    };\n\n                    req.onerror = function () {\n                      return reject(req.error);\n                    };\n                  });\n                }));\n\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function dbRequest(_x, _x2) {\n        return _dbRequest.apply(this, arguments);\n      }\n\n      return dbRequest;\n    }()\n  }, {\n    key: \"dbIndexRequest\",\n    value: function () {\n      var _dbIndexRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(indexName, cmd, args) {\n        var readFlag;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                readFlag = this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';\n                return _context3.abrupt(\"return\", this.initDb().then(function (conn) {\n                  return new Promise(function (resolve, reject) {\n                    var tx = conn.transaction(['FileStorage'], readFlag);\n                    var store = tx.objectStore('FileStorage');\n                    var index = store.index(indexName);\n                    var req = index[cmd].apply(index, _toConsumableArray(args));\n\n                    req.onsuccess = function () {\n                      return resolve(req.result);\n                    };\n\n                    req.onerror = function () {\n                      return reject(req.error);\n                    };\n                  });\n                }));\n\n              case 2:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function dbIndexRequest(_x3, _x4, _x5) {\n        return _dbIndexRequest.apply(this, arguments);\n      }\n\n      return dbIndexRequest;\n    }()\n  }, {\n    key: \"getPath\",\n    value: function getPath(directory, uriPath) {\n      var cleanedUriPath = uriPath !== undefined ? uriPath.replace(/^[/]+|[/]+$/g, '') : '';\n      var fsPath = '';\n      if (directory !== undefined) fsPath += '/' + directory;\n      if (uriPath !== '') fsPath += '/' + cleanedUriPath;\n      return fsPath;\n    }\n  }, {\n    key: \"clear\",\n    value: function () {\n      var _clear = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var conn, tx, store;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.initDb();\n\n              case 2:\n                conn = _context4.sent;\n                tx = conn.transaction(['FileStorage'], 'readwrite');\n                store = tx.objectStore('FileStorage');\n                store.clear();\n\n              case 6:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function clear() {\n        return _clear.apply(this, arguments);\n      }\n\n      return clear;\n    }()\n    /**\n     * Read a file from disk\n     * @param options options for the file read\n     * @return a promise that resolves with the read file data result\n     */\n\n  }, {\n    key: \"readFile\",\n    value: function () {\n      var _readFile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(options) {\n        var path, entry;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                path = this.getPath(options.directory, options.path); // const encoding = options.encoding;\n\n                _context5.next = 3;\n                return this.dbRequest('get', [path]);\n\n              case 3:\n                entry = _context5.sent;\n\n                if (!(entry === undefined)) {\n                  _context5.next = 6;\n                  break;\n                }\n\n                throw Error('File does not exist.');\n\n              case 6:\n                return _context5.abrupt(\"return\", {\n                  data: entry.content ? entry.content : ''\n                });\n\n              case 7:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function readFile(_x6) {\n        return _readFile.apply(this, arguments);\n      }\n\n      return readFile;\n    }()\n    /**\n     * Write a file to disk in the specified location on device\n     * @param options options for the file write\n     * @return a promise that resolves with the file write result\n     */\n\n  }, {\n    key: \"writeFile\",\n    value: function () {\n      var _writeFile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(options) {\n        var path, data, doRecursive, occupiedEntry, encoding, parentPath, parentEntry, subDirIndex, parentArgPath, now, pathObj;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                path = this.getPath(options.directory, options.path);\n                data = options.data;\n                doRecursive = options.recursive;\n                _context6.next = 5;\n                return this.dbRequest('get', [path]);\n\n              case 5:\n                occupiedEntry = _context6.sent;\n\n                if (!(occupiedEntry && occupiedEntry.type === 'directory')) {\n                  _context6.next = 8;\n                  break;\n                }\n\n                throw 'The supplied path is a directory.';\n\n              case 8:\n                encoding = options.encoding;\n                parentPath = path.substr(0, path.lastIndexOf('/'));\n                _context6.next = 12;\n                return this.dbRequest('get', [parentPath]);\n\n              case 12:\n                parentEntry = _context6.sent;\n\n                if (!(parentEntry === undefined)) {\n                  _context6.next = 19;\n                  break;\n                }\n\n                subDirIndex = parentPath.indexOf('/', 1);\n\n                if (!(subDirIndex !== -1)) {\n                  _context6.next = 19;\n                  break;\n                }\n\n                parentArgPath = parentPath.substr(subDirIndex);\n                _context6.next = 19;\n                return this.mkdir({\n                  path: parentArgPath,\n                  directory: options.directory,\n                  recursive: doRecursive\n                });\n\n              case 19:\n                now = Date.now();\n                pathObj = {\n                  path: path,\n                  folder: parentPath,\n                  type: 'file',\n                  size: data.length,\n                  ctime: now,\n                  mtime: now,\n                  content: !encoding && data.indexOf(',') >= 0 ? data.split(',')[1] : data\n                };\n                _context6.next = 23;\n                return this.dbRequest('put', [pathObj]);\n\n              case 23:\n                return _context6.abrupt(\"return\", {\n                  uri: pathObj.path\n                });\n\n              case 24:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function writeFile(_x7) {\n        return _writeFile.apply(this, arguments);\n      }\n\n      return writeFile;\n    }()\n    /**\n     * Append to a file on disk in the specified location on device\n     * @param options options for the file append\n     * @return a promise that resolves with the file write result\n     */\n\n  }, {\n    key: \"appendFile\",\n    value: function () {\n      var _appendFile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(options) {\n        var path, data, parentPath, now, ctime, occupiedEntry, parentEntry, subDirIndex, parentArgPath, pathObj;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                path = this.getPath(options.directory, options.path);\n                data = options.data; // const encoding = options.encoding;\n\n                parentPath = path.substr(0, path.lastIndexOf('/'));\n                now = Date.now();\n                ctime = now;\n                _context7.next = 7;\n                return this.dbRequest('get', [path]);\n\n              case 7:\n                occupiedEntry = _context7.sent;\n\n                if (!(occupiedEntry && occupiedEntry.type === 'directory')) {\n                  _context7.next = 10;\n                  break;\n                }\n\n                throw 'The supplied path is a directory.';\n\n              case 10:\n                _context7.next = 12;\n                return this.dbRequest('get', [parentPath]);\n\n              case 12:\n                parentEntry = _context7.sent;\n\n                if (!(parentEntry === undefined)) {\n                  _context7.next = 19;\n                  break;\n                }\n\n                subDirIndex = parentPath.indexOf('/', 1);\n\n                if (!(subDirIndex !== -1)) {\n                  _context7.next = 19;\n                  break;\n                }\n\n                parentArgPath = parentPath.substr(subDirIndex);\n                _context7.next = 19;\n                return this.mkdir({\n                  path: parentArgPath,\n                  directory: options.directory,\n                  recursive: true\n                });\n\n              case 19:\n                if (occupiedEntry !== undefined) {\n                  data = occupiedEntry.content + data;\n                  ctime = occupiedEntry.ctime;\n                }\n\n                pathObj = {\n                  path: path,\n                  folder: parentPath,\n                  type: 'file',\n                  size: data.length,\n                  ctime: ctime,\n                  mtime: now,\n                  content: data\n                };\n                _context7.next = 23;\n                return this.dbRequest('put', [pathObj]);\n\n              case 23:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function appendFile(_x8) {\n        return _appendFile.apply(this, arguments);\n      }\n\n      return appendFile;\n    }()\n    /**\n     * Delete a file from disk\n     * @param options options for the file delete\n     * @return a promise that resolves with the deleted file data result\n     */\n\n  }, {\n    key: \"deleteFile\",\n    value: function () {\n      var _deleteFile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(options) {\n        var path, entry, entries;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                path = this.getPath(options.directory, options.path);\n                _context8.next = 3;\n                return this.dbRequest('get', [path]);\n\n              case 3:\n                entry = _context8.sent;\n\n                if (!(entry === undefined)) {\n                  _context8.next = 6;\n                  break;\n                }\n\n                throw Error('File does not exist.');\n\n              case 6:\n                _context8.next = 8;\n                return this.dbIndexRequest('by_folder', 'getAllKeys', [IDBKeyRange.only(path)]);\n\n              case 8:\n                entries = _context8.sent;\n\n                if (!(entries.length !== 0)) {\n                  _context8.next = 11;\n                  break;\n                }\n\n                throw Error('Folder is not empty.');\n\n              case 11:\n                _context8.next = 13;\n                return this.dbRequest('delete', [path]);\n\n              case 13:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function deleteFile(_x9) {\n        return _deleteFile.apply(this, arguments);\n      }\n\n      return deleteFile;\n    }()\n    /**\n     * Create a directory.\n     * @param options options for the mkdir\n     * @return a promise that resolves with the mkdir result\n     */\n\n  }, {\n    key: \"mkdir\",\n    value: function () {\n      var _mkdir = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(options) {\n        var path, doRecursive, parentPath, depth, parentEntry, occupiedEntry, parentArgPath, now, pathObj;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                path = this.getPath(options.directory, options.path);\n                doRecursive = options.recursive;\n                parentPath = path.substr(0, path.lastIndexOf('/'));\n                depth = (path.match(/\\//g) || []).length;\n                _context9.next = 6;\n                return this.dbRequest('get', [parentPath]);\n\n              case 6:\n                parentEntry = _context9.sent;\n                _context9.next = 9;\n                return this.dbRequest('get', [path]);\n\n              case 9:\n                occupiedEntry = _context9.sent;\n\n                if (!(depth === 1)) {\n                  _context9.next = 12;\n                  break;\n                }\n\n                throw Error('Cannot create Root directory');\n\n              case 12:\n                if (!(occupiedEntry !== undefined)) {\n                  _context9.next = 14;\n                  break;\n                }\n\n                throw Error('Current directory does already exist.');\n\n              case 14:\n                if (!(!doRecursive && depth !== 2 && parentEntry === undefined)) {\n                  _context9.next = 16;\n                  break;\n                }\n\n                throw Error('Parent directory must exist');\n\n              case 16:\n                if (!(doRecursive && depth !== 2 && parentEntry === undefined)) {\n                  _context9.next = 20;\n                  break;\n                }\n\n                parentArgPath = parentPath.substr(parentPath.indexOf('/', 1));\n                _context9.next = 20;\n                return this.mkdir({\n                  path: parentArgPath,\n                  directory: options.directory,\n                  recursive: doRecursive\n                });\n\n              case 20:\n                now = Date.now();\n                pathObj = {\n                  path: path,\n                  folder: parentPath,\n                  type: 'directory',\n                  size: 0,\n                  ctime: now,\n                  mtime: now\n                };\n                _context9.next = 24;\n                return this.dbRequest('put', [pathObj]);\n\n              case 24:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function mkdir(_x10) {\n        return _mkdir.apply(this, arguments);\n      }\n\n      return mkdir;\n    }()\n    /**\n     * Remove a directory\n     * @param options the options for the directory remove\n     */\n\n  }, {\n    key: \"rmdir\",\n    value: function () {\n      var _rmdir = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(options) {\n        var path, directory, recursive, fullPath, entry, readDirResult, _iterator, _step, _entry, entryPath, entryObj;\n\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                path = options.path, directory = options.directory, recursive = options.recursive;\n                fullPath = this.getPath(directory, path);\n                _context10.next = 4;\n                return this.dbRequest('get', [fullPath]);\n\n              case 4:\n                entry = _context10.sent;\n\n                if (!(entry === undefined)) {\n                  _context10.next = 7;\n                  break;\n                }\n\n                throw Error('Folder does not exist.');\n\n              case 7:\n                if (!(entry.type !== 'directory')) {\n                  _context10.next = 9;\n                  break;\n                }\n\n                throw Error('Requested path is not a directory');\n\n              case 9:\n                _context10.next = 11;\n                return this.readdir({\n                  path: path,\n                  directory: directory\n                });\n\n              case 11:\n                readDirResult = _context10.sent;\n\n                if (!(readDirResult.files.length !== 0 && !recursive)) {\n                  _context10.next = 14;\n                  break;\n                }\n\n                throw Error('Folder is not empty');\n\n              case 14:\n                _iterator = _createForOfIteratorHelper(readDirResult.files);\n                _context10.prev = 15;\n\n                _iterator.s();\n\n              case 17:\n                if ((_step = _iterator.n()).done) {\n                  _context10.next = 32;\n                  break;\n                }\n\n                _entry = _step.value;\n                entryPath = \"\".concat(path, \"/\").concat(_entry);\n                _context10.next = 22;\n                return this.stat({\n                  path: entryPath,\n                  directory: directory\n                });\n\n              case 22:\n                entryObj = _context10.sent;\n\n                if (!(entryObj.type === 'file')) {\n                  _context10.next = 28;\n                  break;\n                }\n\n                _context10.next = 26;\n                return this.deleteFile({\n                  path: entryPath,\n                  directory: directory\n                });\n\n              case 26:\n                _context10.next = 30;\n                break;\n\n              case 28:\n                _context10.next = 30;\n                return this.rmdir({\n                  path: entryPath,\n                  directory: directory,\n                  recursive: recursive\n                });\n\n              case 30:\n                _context10.next = 17;\n                break;\n\n              case 32:\n                _context10.next = 37;\n                break;\n\n              case 34:\n                _context10.prev = 34;\n                _context10.t0 = _context10[\"catch\"](15);\n\n                _iterator.e(_context10.t0);\n\n              case 37:\n                _context10.prev = 37;\n\n                _iterator.f();\n\n                return _context10.finish(37);\n\n              case 40:\n                _context10.next = 42;\n                return this.dbRequest('delete', [fullPath]);\n\n              case 42:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this, [[15, 34, 37, 40]]);\n      }));\n\n      function rmdir(_x11) {\n        return _rmdir.apply(this, arguments);\n      }\n\n      return rmdir;\n    }()\n    /**\n     * Return a list of files from the directory (not recursive)\n     * @param options the options for the readdir operation\n     * @return a promise that resolves with the readdir directory listing result\n     */\n\n  }, {\n    key: \"readdir\",\n    value: function () {\n      var _readdir = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(options) {\n        var path, entry, entries, names;\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                path = this.getPath(options.directory, options.path);\n                _context11.next = 3;\n                return this.dbRequest('get', [path]);\n\n              case 3:\n                entry = _context11.sent;\n\n                if (!(options.path !== '' && entry === undefined)) {\n                  _context11.next = 6;\n                  break;\n                }\n\n                throw Error('Folder does not exist.');\n\n              case 6:\n                _context11.next = 8;\n                return this.dbIndexRequest('by_folder', 'getAllKeys', [IDBKeyRange.only(path)]);\n\n              case 8:\n                entries = _context11.sent;\n                names = entries.map(function (e) {\n                  return e.substring(path.length + 1);\n                });\n                return _context11.abrupt(\"return\", {\n                  files: names\n                });\n\n              case 11:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function readdir(_x12) {\n        return _readdir.apply(this, arguments);\n      }\n\n      return readdir;\n    }()\n    /**\n     * Return full File URI for a path and directory\n     * @param options the options for the stat operation\n     * @return a promise that resolves with the file stat result\n     */\n\n  }, {\n    key: \"getUri\",\n    value: function () {\n      var _getUri = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(options) {\n        var path, entry;\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                path = this.getPath(options.directory, options.path);\n                _context12.next = 3;\n                return this.dbRequest('get', [path]);\n\n              case 3:\n                entry = _context12.sent;\n\n                if (!(entry === undefined)) {\n                  _context12.next = 8;\n                  break;\n                }\n\n                _context12.next = 7;\n                return this.dbRequest('get', [path + '/']);\n\n              case 7:\n                entry = _context12.sent;\n\n              case 8:\n                return _context12.abrupt(\"return\", {\n                  uri: (entry === null || entry === void 0 ? void 0 : entry.path) || path\n                });\n\n              case 9:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function getUri(_x13) {\n        return _getUri.apply(this, arguments);\n      }\n\n      return getUri;\n    }()\n    /**\n     * Return data about a file\n     * @param options the options for the stat operation\n     * @return a promise that resolves with the file stat result\n     */\n\n  }, {\n    key: \"stat\",\n    value: function () {\n      var _stat = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(options) {\n        var path, entry;\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                path = this.getPath(options.directory, options.path);\n                _context13.next = 3;\n                return this.dbRequest('get', [path]);\n\n              case 3:\n                entry = _context13.sent;\n\n                if (!(entry === undefined)) {\n                  _context13.next = 8;\n                  break;\n                }\n\n                _context13.next = 7;\n                return this.dbRequest('get', [path + '/']);\n\n              case 7:\n                entry = _context13.sent;\n\n              case 8:\n                if (!(entry === undefined)) {\n                  _context13.next = 10;\n                  break;\n                }\n\n                throw Error('Entry does not exist.');\n\n              case 10:\n                return _context13.abrupt(\"return\", {\n                  type: entry.type,\n                  size: entry.size,\n                  ctime: entry.ctime,\n                  mtime: entry.mtime,\n                  uri: entry.path\n                });\n\n              case 11:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function stat(_x14) {\n        return _stat.apply(this, arguments);\n      }\n\n      return stat;\n    }()\n    /**\n     * Rename a file or directory\n     * @param options the options for the rename operation\n     * @return a promise that resolves with the rename result\n     */\n\n  }, {\n    key: \"rename\",\n    value: function () {\n      var _rename = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(options) {\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                return _context14.abrupt(\"return\", this._copy(options, true));\n\n              case 1:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function rename(_x15) {\n        return _rename.apply(this, arguments);\n      }\n\n      return rename;\n    }()\n    /**\n     * Copy a file or directory\n     * @param options the options for the copy operation\n     * @return a promise that resolves with the copy result\n     */\n\n  }, {\n    key: \"copy\",\n    value: function () {\n      var _copy2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15(options) {\n        return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                return _context15.abrupt(\"return\", this._copy(options, false));\n\n              case 1:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function copy(_x16) {\n        return _copy2.apply(this, arguments);\n      }\n\n      return copy;\n    }()\n  }, {\n    key: \"requestPermissions\",\n    value: function () {\n      var _requestPermissions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16() {\n        return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                return _context16.abrupt(\"return\", {\n                  publicStorage: 'granted'\n                });\n\n              case 1:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16);\n      }));\n\n      function requestPermissions() {\n        return _requestPermissions.apply(this, arguments);\n      }\n\n      return requestPermissions;\n    }()\n  }, {\n    key: \"checkPermissions\",\n    value: function () {\n      var _checkPermissions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee17() {\n        return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                return _context17.abrupt(\"return\", {\n                  publicStorage: 'granted'\n                });\n\n              case 1:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17);\n      }));\n\n      function checkPermissions() {\n        return _checkPermissions.apply(this, arguments);\n      }\n\n      return checkPermissions;\n    }()\n    /**\n     * Function that can perform a copy or a rename\n     * @param options the options for the rename operation\n     * @param doRename whether to perform a rename or copy operation\n     * @return a promise that resolves with the result\n     */\n\n  }, {\n    key: \"_copy\",\n    value: function () {\n      var _copy3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee19(options) {\n        var _this3 = this;\n\n        var doRename,\n            toDirectory,\n            to,\n            from,\n            fromDirectory,\n            fromPath,\n            toPath,\n            toObj,\n            toPathComponents,\n            _toPath,\n            toParentDirectory,\n            fromObj,\n            updateTime,\n            ctime,\n            file,\n            contents,\n            _iterator2,\n            _step2,\n            filename,\n            _args19 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                doRename = _args19.length > 1 && _args19[1] !== undefined ? _args19[1] : false;\n                toDirectory = options.toDirectory;\n                to = options.to, from = options.from, fromDirectory = options.directory;\n\n                if (!(!to || !from)) {\n                  _context19.next = 5;\n                  break;\n                }\n\n                throw Error('Both to and from must be provided');\n\n              case 5:\n                // If no \"to\" directory is provided, use the \"from\" directory\n                if (!toDirectory) {\n                  toDirectory = fromDirectory;\n                }\n\n                fromPath = this.getPath(fromDirectory, from);\n                toPath = this.getPath(toDirectory, to); // Test that the \"to\" and \"from\" locations are different\n\n                if (!(fromPath === toPath)) {\n                  _context19.next = 10;\n                  break;\n                }\n\n                return _context19.abrupt(\"return\");\n\n              case 10:\n                if (!toPath.startsWith(fromPath)) {\n                  _context19.next = 12;\n                  break;\n                }\n\n                throw Error('To path cannot contain the from path');\n\n              case 12:\n                _context19.prev = 12;\n                _context19.next = 15;\n                return this.stat({\n                  path: to,\n                  directory: toDirectory\n                });\n\n              case 15:\n                toObj = _context19.sent;\n                _context19.next = 29;\n                break;\n\n              case 18:\n                _context19.prev = 18;\n                _context19.t0 = _context19[\"catch\"](12);\n                // To location does not exist, ensure the directory containing \"to\" location exists and is a directory\n                toPathComponents = to.split('/');\n                toPathComponents.pop();\n                _toPath = toPathComponents.join('/'); // Check the containing directory of the \"to\" location exists\n\n                if (!(toPathComponents.length > 0)) {\n                  _context19.next = 29;\n                  break;\n                }\n\n                _context19.next = 26;\n                return this.stat({\n                  path: _toPath,\n                  directory: toDirectory\n                });\n\n              case 26:\n                toParentDirectory = _context19.sent;\n\n                if (!(toParentDirectory.type !== 'directory')) {\n                  _context19.next = 29;\n                  break;\n                }\n\n                throw new Error('Parent directory of the to path is a file');\n\n              case 29:\n                if (!(toObj && toObj.type === 'directory')) {\n                  _context19.next = 31;\n                  break;\n                }\n\n                throw new Error('Cannot overwrite a directory with a file');\n\n              case 31:\n                _context19.next = 33;\n                return this.stat({\n                  path: from,\n                  directory: fromDirectory\n                });\n\n              case 33:\n                fromObj = _context19.sent;\n\n                // Set the mtime/ctime of the supplied path\n                updateTime = /*#__PURE__*/function () {\n                  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee18(path, ctime, mtime) {\n                    var fullPath, entry;\n                    return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n                      while (1) {\n                        switch (_context18.prev = _context18.next) {\n                          case 0:\n                            fullPath = _this3.getPath(toDirectory, path);\n                            _context18.next = 3;\n                            return _this3.dbRequest('get', [fullPath]);\n\n                          case 3:\n                            entry = _context18.sent;\n                            entry.ctime = ctime;\n                            entry.mtime = mtime;\n                            _context18.next = 8;\n                            return _this3.dbRequest('put', [entry]);\n\n                          case 8:\n                          case \"end\":\n                            return _context18.stop();\n                        }\n                      }\n                    }, _callee18);\n                  }));\n\n                  return function updateTime(_x18, _x19, _x20) {\n                    return _ref.apply(this, arguments);\n                  };\n                }();\n\n                ctime = fromObj.ctime ? fromObj.ctime : Date.now();\n                _context19.t1 = fromObj.type;\n                _context19.next = _context19.t1 === 'file' ? 39 : _context19.t1 === 'directory' ? 51 : 86;\n                break;\n\n              case 39:\n                _context19.next = 41;\n                return this.readFile({\n                  path: from,\n                  directory: fromDirectory\n                });\n\n              case 41:\n                file = _context19.sent;\n\n                if (!doRename) {\n                  _context19.next = 45;\n                  break;\n                }\n\n                _context19.next = 45;\n                return this.deleteFile({\n                  path: from,\n                  directory: fromDirectory\n                });\n\n              case 45:\n                _context19.next = 47;\n                return this.writeFile({\n                  path: to,\n                  directory: toDirectory,\n                  data: file.data\n                });\n\n              case 47:\n                if (!doRename) {\n                  _context19.next = 50;\n                  break;\n                }\n\n                _context19.next = 50;\n                return updateTime(to, ctime, fromObj.mtime);\n\n              case 50:\n                return _context19.abrupt(\"return\");\n\n              case 51:\n                if (!toObj) {\n                  _context19.next = 53;\n                  break;\n                }\n\n                throw Error('Cannot move a directory over an existing object');\n\n              case 53:\n                _context19.prev = 53;\n                _context19.next = 56;\n                return this.mkdir({\n                  path: to,\n                  directory: toDirectory,\n                  recursive: false\n                });\n\n              case 56:\n                if (!doRename) {\n                  _context19.next = 59;\n                  break;\n                }\n\n                _context19.next = 59;\n                return updateTime(to, ctime, fromObj.mtime);\n\n              case 59:\n                _context19.next = 63;\n                break;\n\n              case 61:\n                _context19.prev = 61;\n                _context19.t2 = _context19[\"catch\"](53);\n\n              case 63:\n                _context19.next = 65;\n                return this.readdir({\n                  path: from,\n                  directory: fromDirectory\n                });\n\n              case 65:\n                contents = _context19.sent.files;\n                _iterator2 = _createForOfIteratorHelper(contents);\n                _context19.prev = 67;\n\n                _iterator2.s();\n\n              case 69:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context19.next = 75;\n                  break;\n                }\n\n                filename = _step2.value;\n                _context19.next = 73;\n                return this._copy({\n                  from: \"\".concat(from, \"/\").concat(filename),\n                  to: \"\".concat(to, \"/\").concat(filename),\n                  directory: fromDirectory,\n                  toDirectory: toDirectory\n                }, doRename);\n\n              case 73:\n                _context19.next = 69;\n                break;\n\n              case 75:\n                _context19.next = 80;\n                break;\n\n              case 77:\n                _context19.prev = 77;\n                _context19.t3 = _context19[\"catch\"](67);\n\n                _iterator2.e(_context19.t3);\n\n              case 80:\n                _context19.prev = 80;\n\n                _iterator2.f();\n\n                return _context19.finish(80);\n\n              case 83:\n                if (!doRename) {\n                  _context19.next = 86;\n                  break;\n                }\n\n                _context19.next = 86;\n                return this.rmdir({\n                  path: from,\n                  directory: fromDirectory\n                });\n\n              case 86:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this, [[12, 18], [53, 61], [67, 77, 80, 83]]);\n      }));\n\n      function _copy(_x17) {\n        return _copy3.apply(this, arguments);\n      }\n\n      return _copy;\n    }()\n  }], [{\n    key: \"doUpgrade\",\n    value: function doUpgrade(event) {\n      var eventTarget = event.target;\n      var db = eventTarget.result;\n\n      switch (event.oldVersion) {\n        case 0:\n        case 1:\n        default:\n          {\n            if (db.objectStoreNames.contains('FileStorage')) {\n              db.deleteObjectStore('FileStorage');\n            }\n\n            var store = db.createObjectStore('FileStorage', {\n              keyPath: 'path'\n            });\n            store.createIndex('by_folder', 'folder');\n          }\n      }\n    }\n  }]);\n\n  return FilesystemWeb;\n}(WebPlugin);\nFilesystemWeb._debug = true;","map":{"version":3,"sources":["../../src/web.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { WebPlugin } from '@capacitor/core';\nexport class FilesystemWeb extends WebPlugin {\n    constructor() {\n        super(...arguments);\n        this.DB_VERSION = 1;\n        this.DB_NAME = 'Disc';\n        this._writeCmds = ['add', 'put', 'delete'];\n    }\n    async initDb() {\n        if (this._db !== undefined) {\n            return this._db;\n        }\n        if (!('indexedDB' in window)) {\n            throw this.unavailable(\"This browser doesn't support IndexedDB\");\n        }\n        return new Promise((resolve, reject) => {\n            const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);\n            request.onupgradeneeded = FilesystemWeb.doUpgrade;\n            request.onsuccess = () => {\n                this._db = request.result;\n                resolve(request.result);\n            };\n            request.onerror = () => reject(request.error);\n            request.onblocked = () => {\n                console.warn('db blocked');\n            };\n        });\n    }\n    static doUpgrade(event) {\n        const eventTarget = event.target;\n        const db = eventTarget.result;\n        switch (event.oldVersion) {\n            case 0:\n            case 1:\n            default: {\n                if (db.objectStoreNames.contains('FileStorage')) {\n                    db.deleteObjectStore('FileStorage');\n                }\n                const store = db.createObjectStore('FileStorage', { keyPath: 'path' });\n                store.createIndex('by_folder', 'folder');\n            }\n        }\n    }\n    async dbRequest(cmd, args) {\n        const readFlag = this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';\n        return this.initDb().then((conn) => {\n            return new Promise((resolve, reject) => {\n                const tx = conn.transaction(['FileStorage'], readFlag);\n                const store = tx.objectStore('FileStorage');\n                const req = store[cmd](...args);\n                req.onsuccess = () => resolve(req.result);\n                req.onerror = () => reject(req.error);\n            });\n        });\n    }\n    async dbIndexRequest(indexName, cmd, args) {\n        const readFlag = this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';\n        return this.initDb().then((conn) => {\n            return new Promise((resolve, reject) => {\n                const tx = conn.transaction(['FileStorage'], readFlag);\n                const store = tx.objectStore('FileStorage');\n                const index = store.index(indexName);\n                const req = index[cmd](...args);\n                req.onsuccess = () => resolve(req.result);\n                req.onerror = () => reject(req.error);\n            });\n        });\n    }\n    getPath(directory, uriPath) {\n        const cleanedUriPath = uriPath !== undefined ? uriPath.replace(/^[/]+|[/]+$/g, '') : '';\n        let fsPath = '';\n        if (directory !== undefined)\n            fsPath += '/' + directory;\n        if (uriPath !== '')\n            fsPath += '/' + cleanedUriPath;\n        return fsPath;\n    }\n    async clear() {\n        const conn = await this.initDb();\n        const tx = conn.transaction(['FileStorage'], 'readwrite');\n        const store = tx.objectStore('FileStorage');\n        store.clear();\n    }\n    /**\n     * Read a file from disk\n     * @param options options for the file read\n     * @return a promise that resolves with the read file data result\n     */\n    async readFile(options) {\n        const path = this.getPath(options.directory, options.path);\n        // const encoding = options.encoding;\n        const entry = (await this.dbRequest('get', [path]));\n        if (entry === undefined)\n            throw Error('File does not exist.');\n        return { data: entry.content ? entry.content : '' };\n    }\n    /**\n     * Write a file to disk in the specified location on device\n     * @param options options for the file write\n     * @return a promise that resolves with the file write result\n     */\n    async writeFile(options) {\n        const path = this.getPath(options.directory, options.path);\n        const data = options.data;\n        const doRecursive = options.recursive;\n        const occupiedEntry = (await this.dbRequest('get', [path]));\n        if (occupiedEntry && occupiedEntry.type === 'directory')\n            throw 'The supplied path is a directory.';\n        const encoding = options.encoding;\n        const parentPath = path.substr(0, path.lastIndexOf('/'));\n        const parentEntry = (await this.dbRequest('get', [parentPath]));\n        if (parentEntry === undefined) {\n            const subDirIndex = parentPath.indexOf('/', 1);\n            if (subDirIndex !== -1) {\n                const parentArgPath = parentPath.substr(subDirIndex);\n                await this.mkdir({\n                    path: parentArgPath,\n                    directory: options.directory,\n                    recursive: doRecursive,\n                });\n            }\n        }\n        const now = Date.now();\n        const pathObj = {\n            path: path,\n            folder: parentPath,\n            type: 'file',\n            size: data.length,\n            ctime: now,\n            mtime: now,\n            content: !encoding && data.indexOf(',') >= 0 ? data.split(',')[1] : data,\n        };\n        await this.dbRequest('put', [pathObj]);\n        return {\n            uri: pathObj.path,\n        };\n    }\n    /**\n     * Append to a file on disk in the specified location on device\n     * @param options options for the file append\n     * @return a promise that resolves with the file write result\n     */\n    async appendFile(options) {\n        const path = this.getPath(options.directory, options.path);\n        let data = options.data;\n        // const encoding = options.encoding;\n        const parentPath = path.substr(0, path.lastIndexOf('/'));\n        const now = Date.now();\n        let ctime = now;\n        const occupiedEntry = (await this.dbRequest('get', [path]));\n        if (occupiedEntry && occupiedEntry.type === 'directory')\n            throw 'The supplied path is a directory.';\n        const parentEntry = (await this.dbRequest('get', [parentPath]));\n        if (parentEntry === undefined) {\n            const subDirIndex = parentPath.indexOf('/', 1);\n            if (subDirIndex !== -1) {\n                const parentArgPath = parentPath.substr(subDirIndex);\n                await this.mkdir({\n                    path: parentArgPath,\n                    directory: options.directory,\n                    recursive: true,\n                });\n            }\n        }\n        if (occupiedEntry !== undefined) {\n            data = occupiedEntry.content + data;\n            ctime = occupiedEntry.ctime;\n        }\n        const pathObj = {\n            path: path,\n            folder: parentPath,\n            type: 'file',\n            size: data.length,\n            ctime: ctime,\n            mtime: now,\n            content: data,\n        };\n        await this.dbRequest('put', [pathObj]);\n    }\n    /**\n     * Delete a file from disk\n     * @param options options for the file delete\n     * @return a promise that resolves with the deleted file data result\n     */\n    async deleteFile(options) {\n        const path = this.getPath(options.directory, options.path);\n        const entry = (await this.dbRequest('get', [path]));\n        if (entry === undefined)\n            throw Error('File does not exist.');\n        const entries = await this.dbIndexRequest('by_folder', 'getAllKeys', [\n            IDBKeyRange.only(path),\n        ]);\n        if (entries.length !== 0)\n            throw Error('Folder is not empty.');\n        await this.dbRequest('delete', [path]);\n    }\n    /**\n     * Create a directory.\n     * @param options options for the mkdir\n     * @return a promise that resolves with the mkdir result\n     */\n    async mkdir(options) {\n        const path = this.getPath(options.directory, options.path);\n        const doRecursive = options.recursive;\n        const parentPath = path.substr(0, path.lastIndexOf('/'));\n        const depth = (path.match(/\\//g) || []).length;\n        const parentEntry = (await this.dbRequest('get', [parentPath]));\n        const occupiedEntry = (await this.dbRequest('get', [path]));\n        if (depth === 1)\n            throw Error('Cannot create Root directory');\n        if (occupiedEntry !== undefined)\n            throw Error('Current directory does already exist.');\n        if (!doRecursive && depth !== 2 && parentEntry === undefined)\n            throw Error('Parent directory must exist');\n        if (doRecursive && depth !== 2 && parentEntry === undefined) {\n            const parentArgPath = parentPath.substr(parentPath.indexOf('/', 1));\n            await this.mkdir({\n                path: parentArgPath,\n                directory: options.directory,\n                recursive: doRecursive,\n            });\n        }\n        const now = Date.now();\n        const pathObj = {\n            path: path,\n            folder: parentPath,\n            type: 'directory',\n            size: 0,\n            ctime: now,\n            mtime: now,\n        };\n        await this.dbRequest('put', [pathObj]);\n    }\n    /**\n     * Remove a directory\n     * @param options the options for the directory remove\n     */\n    async rmdir(options) {\n        const { path, directory, recursive } = options;\n        const fullPath = this.getPath(directory, path);\n        const entry = (await this.dbRequest('get', [fullPath]));\n        if (entry === undefined)\n            throw Error('Folder does not exist.');\n        if (entry.type !== 'directory')\n            throw Error('Requested path is not a directory');\n        const readDirResult = await this.readdir({ path, directory });\n        if (readDirResult.files.length !== 0 && !recursive)\n            throw Error('Folder is not empty');\n        for (const entry of readDirResult.files) {\n            const entryPath = `${path}/${entry}`;\n            const entryObj = await this.stat({ path: entryPath, directory });\n            if (entryObj.type === 'file') {\n                await this.deleteFile({ path: entryPath, directory });\n            }\n            else {\n                await this.rmdir({ path: entryPath, directory, recursive });\n            }\n        }\n        await this.dbRequest('delete', [fullPath]);\n    }\n    /**\n     * Return a list of files from the directory (not recursive)\n     * @param options the options for the readdir operation\n     * @return a promise that resolves with the readdir directory listing result\n     */\n    async readdir(options) {\n        const path = this.getPath(options.directory, options.path);\n        const entry = (await this.dbRequest('get', [path]));\n        if (options.path !== '' && entry === undefined)\n            throw Error('Folder does not exist.');\n        const entries = await this.dbIndexRequest('by_folder', 'getAllKeys', [IDBKeyRange.only(path)]);\n        const names = entries.map(e => {\n            return e.substring(path.length + 1);\n        });\n        return { files: names };\n    }\n    /**\n     * Return full File URI for a path and directory\n     * @param options the options for the stat operation\n     * @return a promise that resolves with the file stat result\n     */\n    async getUri(options) {\n        const path = this.getPath(options.directory, options.path);\n        let entry = (await this.dbRequest('get', [path]));\n        if (entry === undefined) {\n            entry = (await this.dbRequest('get', [path + '/']));\n        }\n        return {\n            uri: (entry === null || entry === void 0 ? void 0 : entry.path) || path,\n        };\n    }\n    /**\n     * Return data about a file\n     * @param options the options for the stat operation\n     * @return a promise that resolves with the file stat result\n     */\n    async stat(options) {\n        const path = this.getPath(options.directory, options.path);\n        let entry = (await this.dbRequest('get', [path]));\n        if (entry === undefined) {\n            entry = (await this.dbRequest('get', [path + '/']));\n        }\n        if (entry === undefined)\n            throw Error('Entry does not exist.');\n        return {\n            type: entry.type,\n            size: entry.size,\n            ctime: entry.ctime,\n            mtime: entry.mtime,\n            uri: entry.path,\n        };\n    }\n    /**\n     * Rename a file or directory\n     * @param options the options for the rename operation\n     * @return a promise that resolves with the rename result\n     */\n    async rename(options) {\n        return this._copy(options, true);\n    }\n    /**\n     * Copy a file or directory\n     * @param options the options for the copy operation\n     * @return a promise that resolves with the copy result\n     */\n    async copy(options) {\n        return this._copy(options, false);\n    }\n    async requestPermissions() {\n        return { publicStorage: 'granted' };\n    }\n    async checkPermissions() {\n        return { publicStorage: 'granted' };\n    }\n    /**\n     * Function that can perform a copy or a rename\n     * @param options the options for the rename operation\n     * @param doRename whether to perform a rename or copy operation\n     * @return a promise that resolves with the result\n     */\n    async _copy(options, doRename = false) {\n        let { toDirectory } = options;\n        const { to, from, directory: fromDirectory } = options;\n        if (!to || !from) {\n            throw Error('Both to and from must be provided');\n        }\n        // If no \"to\" directory is provided, use the \"from\" directory\n        if (!toDirectory) {\n            toDirectory = fromDirectory;\n        }\n        const fromPath = this.getPath(fromDirectory, from);\n        const toPath = this.getPath(toDirectory, to);\n        // Test that the \"to\" and \"from\" locations are different\n        if (fromPath === toPath) {\n            return;\n        }\n        if (toPath.startsWith(fromPath)) {\n            throw Error('To path cannot contain the from path');\n        }\n        // Check the state of the \"to\" location\n        let toObj;\n        try {\n            toObj = await this.stat({\n                path: to,\n                directory: toDirectory,\n            });\n        }\n        catch (e) {\n            // To location does not exist, ensure the directory containing \"to\" location exists and is a directory\n            const toPathComponents = to.split('/');\n            toPathComponents.pop();\n            const toPath = toPathComponents.join('/');\n            // Check the containing directory of the \"to\" location exists\n            if (toPathComponents.length > 0) {\n                const toParentDirectory = await this.stat({\n                    path: toPath,\n                    directory: toDirectory,\n                });\n                if (toParentDirectory.type !== 'directory') {\n                    throw new Error('Parent directory of the to path is a file');\n                }\n            }\n        }\n        // Cannot overwrite a directory\n        if (toObj && toObj.type === 'directory') {\n            throw new Error('Cannot overwrite a directory with a file');\n        }\n        // Ensure the \"from\" object exists\n        const fromObj = await this.stat({\n            path: from,\n            directory: fromDirectory,\n        });\n        // Set the mtime/ctime of the supplied path\n        const updateTime = async (path, ctime, mtime) => {\n            const fullPath = this.getPath(toDirectory, path);\n            const entry = (await this.dbRequest('get', [fullPath]));\n            entry.ctime = ctime;\n            entry.mtime = mtime;\n            await this.dbRequest('put', [entry]);\n        };\n        const ctime = fromObj.ctime ? fromObj.ctime : Date.now();\n        switch (fromObj.type) {\n            // The \"from\" object is a file\n            case 'file': {\n                // Read the file\n                const file = await this.readFile({\n                    path: from,\n                    directory: fromDirectory,\n                });\n                // Optionally remove the file\n                if (doRename) {\n                    await this.deleteFile({\n                        path: from,\n                        directory: fromDirectory,\n                    });\n                }\n                // Write the file to the new location\n                await this.writeFile({\n                    path: to,\n                    directory: toDirectory,\n                    data: file.data,\n                });\n                // Copy the mtime/ctime of a renamed file\n                if (doRename) {\n                    await updateTime(to, ctime, fromObj.mtime);\n                }\n                // Resolve promise\n                return;\n            }\n            case 'directory': {\n                if (toObj) {\n                    throw Error('Cannot move a directory over an existing object');\n                }\n                try {\n                    // Create the to directory\n                    await this.mkdir({\n                        path: to,\n                        directory: toDirectory,\n                        recursive: false,\n                    });\n                    // Copy the mtime/ctime of a renamed directory\n                    if (doRename) {\n                        await updateTime(to, ctime, fromObj.mtime);\n                    }\n                }\n                catch (e) {\n                    // ignore\n                }\n                // Iterate over the contents of the from location\n                const contents = (await this.readdir({\n                    path: from,\n                    directory: fromDirectory,\n                })).files;\n                for (const filename of contents) {\n                    // Move item from the from directory to the to directory\n                    await this._copy({\n                        from: `${from}/${filename}`,\n                        to: `${to}/${filename}`,\n                        directory: fromDirectory,\n                        toDirectory,\n                    }, doRename);\n                }\n                // Optionally remove the original from directory\n                if (doRename) {\n                    await this.rmdir({\n                        path: from,\n                        directory: fromDirectory,\n                    });\n                }\n            }\n        }\n    }\n}\nFilesystemWeb._debug = true;\n//# sourceMappingURL=web.js.map"]},"metadata":{},"sourceType":"module"}